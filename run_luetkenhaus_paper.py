from quantum_objects import Source, Station
from world import World
from events import SourceEvent
import libs.matrix as mat
import numpy as np
from aux_functions import apply_single_qubit_map, x_noise_channel, y_noise_channel, z_noise_channel


ETA_P = 0.66  # preparation efficiency
T_P = 2 * 10**-6  # preparation time
ETA_C = 0.04 * 0.3  # phton-fiber coupling efficiency * wavelength conversion
T_2 = 1  # dephasing time
C = 2 * 10**8 # speed of light in optical fiber
L_ATT = 22 * 10**3  # attenuation length
E_M_A = 0.01  # misalignment error
P_D = 10**-8  # dark count probability per detector
ETA_D = 0.3  # detector efficiency
P_BSM = 1  # BSM success probability
LAMBDA_BSM = 0.97  # BSM ideality parameter
F = 1.16  # error correction inefficiency
L_TOT = 66 * 10**3  # total distance between A and B

ETA_TOT = ETA_P * ETA_C * ETA_D


class SchedulingSource(Source):
    """A Source that schedules its next event according to a distribution.

    Parameters
    ----------
    see Source

    time_distribution : callable
        Used for scheduling. Should return the amount of time until the next
        SourceEvent should take place (possibly probabilistic).
    state_generation : callable
        Should return (possibly probabilistically) the density matrix of the
        pair generated by the source. Takes the source as input.

    """
    def __init__(self, world, position, target_stations, time_distribution, state_generation):
        self.time_distribution = time_distribution
        self.state_generation = state_generation
        super(SchedulingSource, self).__init__(world, position, target_stations)

    def schedule_event(self):
        time_delay = self.time_distribution(source=self)
        scheduled_time = self.event_queue.current_time + time_delay
        initial_state = self.state_generation(source=self)  # should accurately describe state at the scheduled time
        source_event = SourceEvent(time=scheduled_time, source=self, initial_state=initial_state)
        self.event_queue.add_event(source_event)
        return source_event

def construct_dephasing_noise_channel(dephasing_time):
    def lambda_dp(t):
        return (1 - np.exp(-t/dephasing_time)) / 2

    def dephasing_noise_channel(rho, t):
        return z_noise_channel(rho=rho, epsilon=lambda_dp(t))

    return dephasing_noise_channel

def luetkenhaus_time_distribution(source):
    eta_effective = 1 - (1 - ETA_TOT) * (1 - P_D)**2
    comm_distance = np.max(np.abs(source.position - source.target_stations[0].position), np.abs(source.position - source.target_stations[1].position))
    trial_time = T_P + 2 * comm_distance / C  # I don't think that paper uses latency time and loading time?
    return np.random.geometric(eta_effective) * trial_time

def luetkenhaus_state_generation(source):
    state = np.dot(mat.phiplus, mat.H(mat.phiplus))
    # TODO needs more sophisticated handling for other scenarios - especially if not only the central station is faulty
    comm_distance = np.max(np.abs(source.position - source.target_stations[0].position), np.abs(source.position - source.target_stations[1].position))
    storage_time = 2 * comm_distance / C
    for idx, station in enumerate(source.target_stations):
        if station.memory_noise is not None:
            state = apply_single_qubit_map(map_func=station.memory_noise, qubit_index=idx, rho=state, t=storage_time)
        # misalignment
        state = apply_single_qubit_map(map_func=y_noise_channel, qubit_index=idx, rho=state, epsilon=E_M_A)
    return state


if __name__ = "__main__":
    world = World()
    station_A = Station(world, id=0, position=0, memory_noise=None)
    station_B = Station(world, id=1, position=L_TOT, memory_noise=None)
    station_central = Station(world, id=2, position=L_TOT/2, memory_noise=construct_dephasing_noise_channel(dephasing_time=T_2))
    source_A = SchedulingSource(world, position=L_TOT/2, target_stations=[station_A, station_central], time_distribution=luetkenhaus_time_distribution)
    source_B = SchedulingSource(world, position=L_TOT/2, target_stations=[station_central, station_B], time_distribution=luetkenhaus_time_distribution)

    # state generation loop
    
