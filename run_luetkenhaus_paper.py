from quantum_objects import Source, Station, Pair
from world import World
from events import SourceEvent, GenericEvent
import libs.matrix as mat
import numpy as np
from aux_functions import apply_single_qubit_map, x_noise_channel, y_noise_channel, z_noise_channel


ETA_P = 0.66  # preparation efficiency
T_P = 2 * 10**-6  # preparation time
ETA_C = 0.04 * 0.3  # phton-fiber coupling efficiency * wavelength conversion
T_2 = 1  # dephasing time
C = 2 * 10**8 # speed of light in optical fiber
L_ATT = 22 * 10**3  # attenuation length
E_M_A = 0.01  # misalignment error
P_D = 10**-8  # dark count probability per detector
ETA_D = 0.3  # detector efficiency
P_BSM = 1  # BSM success probability
LAMBDA_BSM = 0.97  # BSM ideality parameter
F = 1.16  # error correction inefficiency
L_TOT = 66 * 10**3  # total distance between A and B

ETA_TOT = ETA_P * ETA_C * ETA_D


class SchedulingSource(Source):
    """A Source that schedules its next event according to a distribution.

    Parameters
    ----------
    see Source

    time_distribution : callable
        Used for scheduling. Should return the amount of time until the next
        SourceEvent should take place (possibly probabilistic).
    state_generation : callable
        Should return (possibly probabilistically) the density matrix of the
        pair generated by the source. Takes the source as input.

    """
    def __init__(self, world, position, target_stations, time_distribution, state_generation):
        self.time_distribution = time_distribution
        self.state_generation = state_generation
        super(SchedulingSource, self).__init__(world, position, target_stations)

    def schedule_event(self):
        time_delay = self.time_distribution(source=self)
        scheduled_time = self.event_queue.current_time + time_delay
        initial_state = self.state_generation(source=self)  # should accurately describe state at the scheduled time
        source_event = SourceEvent(time=scheduled_time, source=self, initial_state=initial_state)
        self.event_queue.add_event(source_event)
        return source_event

def construct_dephasing_noise_channel(dephasing_time):
    def lambda_dp(t):
        return (1 - np.exp(-t/dephasing_time)) / 2

    def dephasing_noise_channel(rho, t):
        return z_noise_channel(rho=rho, epsilon=lambda_dp(t))

    return dephasing_noise_channel

def luetkenhaus_time_distribution(source):
    comm_distance = np.max([np.abs(source.position - source.target_stations[0].position), np.abs(source.position - source.target_stations[1].position)])
    eta = ETA_TOT * np.exp(-comm_distance / L_ATT)
    eta_effective = 1 - (1 - eta) * (1 - P_D)**2
    trial_time = T_P + 2 * comm_distance / C  # I don't think that paper uses latency time and loading time?
    return np.random.geometric(eta_effective) * trial_time

def luetkenhaus_state_generation(source):
    state = np.dot(mat.phiplus, mat.H(mat.phiplus))
    # TODO needs more sophisticated handling for other scenarios - especially if not only the central station is faulty
    comm_distance = np.max([np.abs(source.position - source.target_stations[0].position), np.abs(source.position - source.target_stations[1].position)])
    storage_time = 2 * comm_distance / C
    for idx, station in enumerate(source.target_stations):
        if station.memory_noise is not None:
            state = apply_single_qubit_map(map_func=station.memory_noise, qubit_index=idx, rho=state, t=storage_time)
        # misalignment
        state = apply_single_qubit_map(map_func=y_noise_channel, qubit_index=idx, rho=state, epsilon=E_M_A)
    return state


if __name__ == "__main__":
    world = World()
    station_A = Station(world, id=0, position=0, memory_noise=None)
    station_B = Station(world, id=1, position=L_TOT, memory_noise=None)
    station_central = Station(world, id=2, position=L_TOT/2, memory_noise=construct_dephasing_noise_channel(dephasing_time=T_2))
    source_A = SchedulingSource(world, position=L_TOT/2, target_stations=[station_A, station_central], time_distribution=luetkenhaus_time_distribution, state_generation=luetkenhaus_state_generation)
    source_B = SchedulingSource(world, position=L_TOT/2, target_stations=[station_central, station_B], time_distribution=luetkenhaus_time_distribution, state_generation=luetkenhaus_state_generation)

    # state generation loop - this is for sequential loading so far
    event_A = source_A.schedule_event()
    event_schedule_B = GenericEvent(time=event_A.time, resolve_function=source_B.schedule_event)
    world.event_queue.add_event(event_schedule_B)
    while world.event_queue.queue:
        world.event_queue.resolve_next_event()
    # then do entanglement swapping
    left_pair = world.world_objects["Pair"][0]
    right_pair = world.world_objects["Pair"][1]
    assert left_pair.qubits[1].station is station_central
    assert right_pair.qubits[0].station is station_central
    four_qubit_state = mat.tensor(left_pair.state, right_pair.state)
    # non-ideal-bell-measurement
    four_qubit_state = LAMBDA_BSM * four_qubit_state + (1-LAMBDA_BSM) * mat.reorder(mat.tensor(mat.ptrace(four_qubit_state, [1, 2]), mat.I(4) / 4), [0, 2, 3, 1])
    my_proj = mat.tensor(mat.I(2), mat.phiplus, mat.I(2))
    two_qubit_state = np.dot(np.dot(mat.H(my_proj), four_qubit_state), my_proj)
    new_pair = Pair(world=world, qubits=[left_pair.qubits[0], right_pair.qubits[1]], initial_state=two_qubit_state)
    # cleanup
    left_pair.qubits[1].destroy()
    right_pair.qubits[0].destroy()
    left_pair.destroy()
    right_pair.destroy()
