from quantum_objects import Source, Station, Pair
from world import World
from events import SourceEvent, GenericEvent
import libs.matrix as mat
import numpy as np
from aux_functions import apply_single_qubit_map, x_noise_channel, y_noise_channel, z_noise_channel, w_noise_channel
import matplotlib.pyplot as plt


ETA_P = 0.66  # preparation efficiency
T_P = 2 * 10**-6  # preparation time
ETA_C = 0.04 * 0.3  # phton-fiber coupling efficiency * wavelength conversion
T_2 = 1  # dephasing time
C = 2 * 10**8 # speed of light in optical fiber
L_ATT = 22 * 10**3  # attenuation length
E_M_A = 0.01  # misalignment error
P_D = 10**-8  # dark count probability per detector
ETA_D = 0.3  # detector efficiency
P_BSM = 1  # BSM success probability
LAMBDA_BSM = 0.97  # BSM ideality parameter
F = 1.16  # error correction inefficiency
L_TOT = 66 * 10**3  # total distance between A and B

ETA_TOT = ETA_P * ETA_C * ETA_D


class SchedulingSource(Source):
    """A Source that schedules its next event according to a distribution.

    Parameters
    ----------
    see Source

    time_distribution : callable
        Used for scheduling. Should return the amount of time until the next
        SourceEvent should take place (possibly probabilistic).
    state_generation : callable
        Should return (possibly probabilistically) the density matrix of the
        pair generated by the source. Takes the source as input.

    """
    def __init__(self, world, position, target_stations, time_distribution, state_generation):
        self.time_distribution = time_distribution
        self.state_generation = state_generation
        super(SchedulingSource, self).__init__(world, position, target_stations)

    def schedule_event(self):
        time_delay = self.time_distribution(source=self)
        scheduled_time = self.event_queue.current_time + time_delay
        initial_state = self.state_generation(source=self)  # should accurately describe state at the scheduled time
        source_event = SourceEvent(time=scheduled_time, source=self, initial_state=initial_state)
        self.event_queue.add_event(source_event)
        return source_event

def construct_dephasing_noise_channel(dephasing_time):
    def lambda_dp(t):
        return (1 - np.exp(-t/dephasing_time)) / 2

    def dephasing_noise_channel(rho, t):
        return z_noise_channel(rho=rho, epsilon=lambda_dp(t))

    return dephasing_noise_channel

def luetkenhaus_time_distribution(source):
    comm_distance = np.max([np.abs(source.position - source.target_stations[0].position), np.abs(source.position - source.target_stations[1].position)])
    eta = ETA_TOT * np.exp(-comm_distance / L_ATT)
    eta_effective = 1 - (1 - eta) * (1 - P_D)**2
    trial_time = T_P + 2 * comm_distance / C  # I don't think that paper uses latency time and loading time?
    return np.random.geometric(eta_effective) * trial_time

def luetkenhaus_state_generation(source):
    state = np.dot(mat.phiplus, mat.H(mat.phiplus))
    # TODO needs more sophisticated handling for other scenarios - especially if not only the central station is faulty
    comm_distance = np.max([np.abs(source.position - source.target_stations[0].position), np.abs(source.position - source.target_stations[1].position)])
    storage_time = 2 * comm_distance / C
    for idx, station in enumerate(source.target_stations):
        if station.memory_noise is not None:
            state = apply_single_qubit_map(map_func=station.memory_noise, qubit_index=idx, rho=state, t=storage_time)
        # misalignment
        if station.position == 0 or station.position == L_TOT:  # only count misalignment and dark counts for end stations
            state = apply_single_qubit_map(map_func=y_noise_channel, qubit_index=idx, rho=state, epsilon=E_M_A)
            eta = ETA_TOT * np.exp(-comm_distance / L_ATT)
            eta_effective = 1 - (1 - eta) * (1 - P_D)**2
            alpha_of_eta = eta * (1 - P_D) / eta_effective
            state = apply_single_qubit_map(map_func=w_noise_channel, qubit_index=idx, rho=state, alpha=alpha_of_eta)
    return state

# def noisy_bell_measurement(left_pair, right_pair, noise_channel)
#     pass

def binary_entropy(p):
    return -p * np.log2(p) - (1 - p) * np.log2((1 - p))

def calculate_keyrate_time(correlations_z, correlations_x, err_corr_ineff, time_interval):
    e_z = 1 - np.sum(correlations_z)/len(correlations_z)
    e_x = 1 - np.sum(correlations_x)/len(correlations_x)
    return len(correlations_z) / time_interval * (1 - binary_entropy(e_x) - err_corr_ineff * binary_entropy(e_z))

# def calculate_keyrate_channel_use():
#     pass

if __name__ == "__main__":
    world = World()
    station_A = Station(world, id=0, position=0, memory_noise=None)
    station_B = Station(world, id=1, position=L_TOT, memory_noise=None)
    station_central = Station(world, id=2, position=L_TOT/2, memory_noise=construct_dephasing_noise_channel(dephasing_time=T_2))
    source_A = SchedulingSource(world, position=L_TOT/2, target_stations=[station_A, station_central], time_distribution=luetkenhaus_time_distribution, state_generation=luetkenhaus_state_generation)
    source_B = SchedulingSource(world, position=L_TOT/2, target_stations=[station_central, station_B], time_distribution=luetkenhaus_time_distribution, state_generation=luetkenhaus_state_generation)

    time_list = []
    fidelity_list = []
    correlations_z_list = []
    correlations_x_list = []
    key_rate_time_list = []
    plt.ion()
    fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1)
    fig.tight_layout(pad=3.0)
    # state generation loop - this is for sequential loading so far
    for i_loop in range(1000):
        event_A = source_A.schedule_event()
        event_schedule_B = GenericEvent(time=event_A.time, resolve_function=source_B.schedule_event)
        world.event_queue.add_event(event_schedule_B)
        while world.event_queue.queue:
            world.event_queue.resolve_next_event()
        # then do entanglement swapping
        left_pair = world.world_objects["Pair"][0]
        right_pair = world.world_objects["Pair"][1]
        assert left_pair.qubits[1].station is station_central
        assert right_pair.qubits[0].station is station_central
        left_pair.update_time()
        right_pair.update_time()
        four_qubit_state = mat.tensor(left_pair.state, right_pair.state)
        # non-ideal-bell-measurement
        four_qubit_state = LAMBDA_BSM * four_qubit_state + (1-LAMBDA_BSM) * mat.reorder(mat.tensor(mat.ptrace(four_qubit_state, [1, 2]), mat.I(4) / 4), [0, 2, 3, 1])
        my_proj = mat.tensor(mat.I(2), mat.phiplus, mat.I(2))
        two_qubit_state = np.dot(np.dot(mat.H(my_proj), four_qubit_state), my_proj)
        two_qubit_state = two_qubit_state / np.trace(two_qubit_state)
        new_pair = Pair(world=world, qubits=[left_pair.qubits[0], right_pair.qubits[1]], initial_state=two_qubit_state)
        comm_distance = np.max([np.abs(left_pair.qubits[1].station.position - left_pair.qubits[0].station.position), np.abs(right_pair.qubits[1].station.position - right_pair.qubits[0].station.position)])
        world.event_queue.current_time += comm_distance / C
        # cleanup
        left_pair.qubits[1].destroy()
        right_pair.qubits[0].destroy()
        left_pair.destroy()
        right_pair.destroy()

        pair_fidelity = np.dot(np.dot(mat.H(mat.phiplus), new_pair.state), mat.phiplus)[0, 0]
        time_list += [world.event_queue.current_time]
        fidelity_list += [pair_fidelity]

        z0z0 = mat.tensor(mat.z0, mat.z0)
        z1z1 = mat.tensor(mat.z1, mat.z1)
        correlations_z = np.dot(np.dot(mat.H(z0z0), new_pair.state), z0z0)[0, 0] +  np.dot(np.dot(mat.H(z1z1), new_pair.state), z1z1)[0, 0]
        correlations_z_list += [correlations_z]

        x0x0 = mat.tensor(mat.x0, mat.x0)
        x1x1 = mat.tensor(mat.x1, mat.x1)
        correlations_x = np.dot(np.dot(mat.H(x0x0), new_pair.state), x0x0)[0, 0] +  np.dot(np.dot(mat.H(x1x1), new_pair.state), x1x1)[0, 0]
        correlations_x_list += [correlations_x]

        key_rate_time_list += [calculate_keyrate_time(correlations_z_list, correlations_x_list, F, world.event_queue.current_time)]

        new_pair.qubits[0].destroy()
        new_pair.qubits[1].destroy()
        new_pair.destroy()

        if i_loop % 10 == 0:

            ax1.clear()
            ax1.scatter(time_list, fidelity_list)
            ax1.set_ylim(0, 1)
            ax1.set_xlim(0)
            ax1.grid()
            ax1.set_xlabel("Time (in seconds)")
            ax1.set_ylabel("Fidelity")


            ax2.clear()
            ax2.set_xlim(*ax1.get_xlim())
            ax2.set_yscale("log")
            # ax2.set_ylim(10**-7, 10**-3)
            ax2.plot(time_list, key_rate_time_list)
            ax2.grid()
            ax2.set_xlabel("Time (in seconds)")
            ax2.set_ylabel("averaged key rate until now")

            plt.show()
            plt.pause(0.002)

    input("Input something to continue.")
